---
title: "AATK"
runtime: shiny
output: 
  html_document:
    toc: TRUE
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Introduction to the Policy Questions

The purpose of the research is to inform resource allocation decisions for the Commander of *United States Forces Korea* (USFK), the *Combined Forces Commander* (CFC), and the *Joint Forces Air Component Commander* (JFACC).  


1. The main policy question is how effective were we in hitting targets of interest? What weapons accomplished the kills and how long did it take us to take out all the intended targets?

2. Besides the main targets, where else were hits executed? How did these hits progress over time and what weapons were used? 

# Data Sources and Content
The sources of data for include the outputs of a federation of 19 simulations. Thus far the *AWSIM Analysis Tool Kit* (AATK) has relied heavily on *AWSIM ...?* (ASTABs), and XYZ. 

#Analysis Software
AATK uses **R**, "a language and environment for statistical computing and graphics." **R** is an open source programming language which is greatly enriched with *packages* created by developers and users seeking to maker their work more efficient. In order to execute the AATK, we have imported the necessary packages onto the system already. However, it is likely that there will be updates and new technology in the future. Therefore the following functions were developed for downloading packages with their dependencies and installing them continuously (rather than one by one) on stop-gapped systems. 

### Download Code
```{r}
# Package downloader from https://stackoverflow.com/questions/17190103/offline-installation-of-r-packages
# Set the packages you want to install as a char vector and the destination directory

#=========================================================
PACKAGES_TO_INSTALL = c('list', 'package', 'names') #c('ggplot2', 'shiny', 'dplyr', 'tidyr')
DEST_DIR = '/destination/to/save/downloads/in' #/home/gregory/Downloads'
#=========================================================

downloadPackages = function(packageList, downloadDirectory){
  dependentPackages = unlist(
    tools::package_dependencies(
      packageList,
      available.packages(),
      which = c('Depends', 'Imports'),
      recursive = TRUE
    )
  )
  packages = union(packageList, dependentPackages)

  try(download.packages(
      pkgs = packages,
      destdir = downloadDirectory,
      type = 'win.binary'
      ))
}
```

### Install Code
```{r}
# Installs all packages from their binary files, stored in a user-defined directory

#===========================================================
PACKAGE_DIR = 'directory/containing/package/zip/files'
#===========================================================

installPackages = function(directory) {
    files = dir(directory)
    for (file in files) {
        if (tolower(tools::file_ext(file)) == 'zip') {
            print(paste0('Attempting to install package from ', file, '...'))
            try(install.packages(paste0(PACKAGE_DIR, '/', file), repos = NULL, type = 'source'))
        }
    }
}
```
# Importing and Cleaning the Data

##Importing
The data is imported to **filepath** every **XYZ** minutes according to the following code which implements *TaskScheduleR*. 
  
###Import Code
  
##Cleaning
The ASTAB Report is a tab delimited file. Tab delimited means that every chunk of information is signalled by "\\t" in the raw file. This enables us to parse or dividing the raw data into meaningful pieces which can then be analyzed. The code for doing so is as follows:

###Cleaning Code

The cleaning code relies on the type of delimiter and the structure of the data file. Notice how in the code above these values can easily be changed to adapt to different outputs.

# The Basic Analysis

Now that we have clean data sets imported we focus on the analysis. First we need to access the following *packages* from our library. 

```{r message = FALSE}

library(dplyr)
library(ggmap)
library(ggplot2)
library(mapdata)
library(maps)

```

The following code draws a map of Korea according to latitude and longitude and plots point series. 

```{r}

rm(list = ls())

m = map_data('worldHires')

countries = m %>%
  distinct(region)

korea = m %>%
  filter(region %in% c('South Korea', 'North Korea'))


# -------------------- controls------------------------------
RATIO = 1
N_POINTS = 10
LONG_POINTS = min(korea$long) + (max(korea$long) - min(korea$long)) *runif(N_POINTS)
LAT_POINTS = min(korea$lat) + (max(korea$lat) - min(korea$lat)) *runif(N_POINTS)
# -------------------- controls------------------------------


gg = ggplot() + geom_polygon(data = korea, aes(x=long, y = lat, group = group), fill = 'white', color = 'black') + 
  coord_fixed(RATIO)
 
points =  data.frame(
  long = LONG_POINTS,
  lat = LAT_POINTS
) 

gg + geom_point(data = points, aes(x = long, y = lat), color = "black", size = 1)

```

# Creating a Shiny App
```#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#

library(shiny)
library(shinythemes)
library(dplyr)
library(readr)
library(ggmap)
library(ggplot2)
library(mapdata)
library(maps)
library(shinyWidgets)

data<- read_csv("testdataMakeup.csv")
m = map_data('worldHires')

countries = m %>%
  distinct(region)

korea = m %>%
  filter(region %in% c('South Korea', 'North Korea'))

RATIO = 1


 # Define UI for application that draws a histogram
 ui <- fluidPage(

   # Application title
   titlePanel("Korea1"),

   # Sidebar with a date range input
   sidebarLayout(
      sidebarPanel(
        
        #Time range Slider Input
        sliderInput("datetime",
                    label = "Time range",
                    min = as.POSIXct("2018-04-14 12:00:00"),
                    max = as.POSIXct("2018-04-30 14:00:00"),
                    value = c(
                      as.POSIXct("2018-04-14 12:00:00"),
                      as.POSIXct("2018-04-30 14:00:00")
                    )
        ),
        #actionButton("update", "Update range")
        pickerInput(inputId = "goalPicker",
                    label = "select goals",
                    choices = unique(data$goal),
                    options = list(
                      `actions-box` = TRUE,
                      size = 12,
                      `selected-text-format` = "count >3"
                    ),
                    multiple =TRUE
                    ),
        pickerInput(inputId = "typePicker",
                    label = "select types",
                    choices = unique(data$type),
                    options = list(
                      `actions-box` = TRUE,
                      size = 12,
                      `selected-text-format` = "count >3"
                    ),
                    multiple =TRUE
        )
      ),

      # Show a plot of the generated distribution
      mainPanel(
        plotOutput(outputId = "scatterplot")
        
      )
   )
)

# Define server logic required to draw a histogram
server <- function(input, output) {
  
  data_subset <- reactive({
    #req(input$datetime)
    #req(input$goalPicker)
    #req(input$typePicker)
    data %>% filter((goal %in% input$goalPicker| 
                      type %in% input$typePicker))
    
  })
  
  output$scatterplot <- renderPlot({
   ggplot(data = data_subset(), 
          aes(x =long, y =lat)) + 
    geom_point() +
    geom_polygon(data = korea,
          aes(x=long, y =lat, group = group),
          fill = 'white', color = 'black') + 
    coord_fixed(RATIO)
  })
  
  
  output$from <- renderText(input$timeRange[1])
  output$to <- renderText(input$timeRange[2])
  observeEvent(input$update, {
    updateSliderInput(session, "timeRange", 
      value = c(
        as.POSIXct("2018-04-25 12:00:00"),
        as.POSIXct("2018-04-29 14:00:00"))
    )
  })


}

# Run the application
shinyApp(ui = ui, server = server)



```
# Product Production





